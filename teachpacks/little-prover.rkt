#lang racket/base
(require
  "../lang/dracula.rkt"
  "../lang/do-check.rkt"
  "j-bob-lang.rkt"
  "j-bob.rkt")
(provide (all-defined-out))

(begin-below

  ;; chapter 1

  (defun chapter1.example1 ()
    (j-bob/step (prelude)
      '(car (cons 'ham '(eggs)))
      '(((1) (cons 'ham '(eggs)))
        (() (car '(ham eggs))))))

  (defun chapter1.example2 ()
    (j-bob/step (prelude)
      '(atom '())
      '((() (atom '())))))

  (defun chapter1.example3 ()
    (j-bob/step (prelude)
      '(atom (cons 'ham '(eggs)))
      '(((1) (cons 'ham '(eggs)))
        (() (atom '(ham eggs))))))

  (defun chapter1.example4 ()
    (j-bob/step (prelude)
      '(atom (cons a b))
      '((() (atom/cons a b)))))

  (defun chapter1.example5 ()
    (j-bob/step (prelude)
      '(equal 'flapjack (atom (cons a b)))
      '(((2) (atom/cons a b))
        (() (equal 'flapjack 'nil)))))

  (defun chapter1.example6 ()
    (j-bob/step (prelude)
      '(atom (cdr (cons (car (cons p q)) '())))
      '(((1 1 1) (car/cons p q))
        ((1) (cdr/cons p '()))
        (() (atom '())))))

  (defun chapter1.example7 ()
    (j-bob/step (prelude)
      '(atom (cdr (cons (car (cons p q)) '())))
      '(((1) (cdr/cons (car (cons p q)) '()))
        (() (atom '())))))

  (defun chapter1.example8 ()
    (j-bob/step (prelude)
      '(car (cons (equal (cons x y) (cons x y)) '(and crumpets)))
      '(((1 1) (equal-same (cons x y)))
        ((1) (cons 't '(and crumpets)))
        (() (car '(t and crumpets))))))

  (defun chapter1.example9 ()
    (j-bob/step (prelude)
      '(equal (cons x y) (cons 'bagels '(and lox)))
      '((() (equal-swap (cons x y) (cons 'bagels '(and lox)))))))

  (defun chapter1.example10 ()
    (j-bob/step (prelude)
      '(cons y (equal (car (cons (cdr x) (car y))) (equal (atom x) 'nil)))
      '(((2 1) (car/cons (cdr x) (car y))))))

  (defun chapter1.example11 ()
    (j-bob/step (prelude)
      '(cons y (equal (car (cons (cdr x) (car y))) (equal (atom x) 'nil)))
      '(((2 1) (car/cons (car (cons (cdr x) (car y))) '(oats)))
        ((2 2 2) (atom/cons (atom (cdr (cons a b))) (equal (cons a b) c)))
        ((2 2 2 1 1 1) (cdr/cons a b))
        ((2 2 2 1 2) (equal-swap (cons a b) c)))))

  (defun chapter1.example12 ()
    (j-bob/step (prelude)
      '(atom (car (cons (car a) (cdr b))))
      '(((1) (car/cons (car a) (cdr b))))))

  ;; chapter 2

  (defun chapter2.example1 ()
    (j-bob/step (prelude)
      '(if (car (cons a b)) c c)
      '(((q) (car/cons a b))
        (() (if-same a c))
        (()
         (if-same
           (if (equal a 't) (if (equal 'nil 'nil) a b) (equal 'or (cons 'black '(coffee))))
           c))
        ((q e 2) (cons 'black '(coffee)))
        ((q a q) (equal-same 'nil))
        ((q a) (if-true a b))
        ((q a) (equal-if a 't)))))

  (defun chapter2.example2 ()
    (j-bob/step (prelude)
      '(if (atom (car a))
           (if (equal (car a) (cdr a)) 'hominy 'grits)
           (if (equal (cdr (car a)) '(hash browns))
               (cons 'ketchup (car a))
               (cons 'mustard (car a))))
      '(((e a 2) (cons/car+cdr (car a)))
        ((e a 2 2) (equal-if (cdr (car a)) '(hash browns))))))

  (defun chapter2.example3 ()
    (j-bob/step (prelude)
      '(cons 'statement
         (cons (if (equal a 'question) (cons n '(answer)) (cons n '(else)))
           (if (equal a 'question) (cons n '(other answer)) (cons n '(other else)))))
      '(((2)
         (if-same (equal a 'question)
           (cons (if (equal a 'question) (cons n '(answer)) (cons n '(else)))
             (if (equal a 'question) (cons n '(other answer)) (cons n '(other else))))))
        ((2 a 1) (if-nest-a (equal a 'question) (cons n '(answer)) (cons n '(else))))
        ((2 e 1) (if-nest-e (equal a 'question) (cons n '(answer)) (cons n '(else))))
        ((2 a 2)
         (if-nest-a (equal a 'question) (cons n '(other answer)) (cons n '(other else))))
        ((2 e 2)
         (if-nest-e (equal a 'question)
           (cons n '(other answer))
           (cons n '(other else)))))))

  ;; chapter 3

  (defun defun.pair ()
    (j-bob/define (prelude)
      '(((defun pair (x y)
           (cons x (cons y '())))
         nil))))

  (defun defun.first-of ()
    (j-bob/define (defun.pair)
      '(((defun first-of (x)
           (car x))
         nil))))

  (defun defun.second-of ()
    (j-bob/define (defun.first-of)
      '(((defun second-of (x)
           (car (cdr x)))
         nil))))

  (defun dethm.first-of-pair ()
    (j-bob/define (defun.second-of)
      '(((dethm first-of-pair (a b)
           (equal (first-of (pair a b)) a))
         nil
         ((1 1) (pair a b))
         ((1) (first-of (cons a (cons b '()))))
         ((1) (car/cons a (cons b '())))
         (() (equal-same a))))))

  (defun dethm.second-of-pair ()
    (j-bob/define (dethm.first-of-pair)
      '(((dethm second-of-pair (a b)
           (equal (second-of (pair a b)) b))
         nil
         ((1) (second-of (pair a b)))
         ((1 1 1) (pair a b))
         ((1 1) (cdr/cons a (cons b '())))
         ((1) (car/cons b '()))
         (() (equal-same b))))))

  (defun defun.in-pair? ()
    (j-bob/define (dethm.second-of-pair)
      '(((defun in-pair? (xs)
           (if (equal (first-of xs) '?) 't (equal (second-of xs) '?)))
         nil))))

  (defun dethm.in-first-of-pair ()
    (j-bob/define (defun.in-pair?)
      '(((dethm in-first-of-pair (b)
           (equal (in-pair? (pair '? b)) 't))
         nil
         ((1 1) (pair '? b))
         ((1) (in-pair? (cons '? (cons b '()))))
         ((1 q 1) (first-of (cons '? (cons b '()))))
         ((1 q 1) (car/cons '? (cons b '())))
         ((1 q) (equal-same '?))
         ((1) (if-true 't (equal (second-of (cons '? (cons b '()))) '?)))
         (() (equal-same 't))))))

  (defun dethm.in-second-of-pair ()
    (j-bob/define (dethm.in-first-of-pair)
      '(((dethm in-second-of-pair (a)
           (equal (in-pair? (pair a '?)) 't))
         nil
         ((1 1) (pair a '?))
         ((1) (in-pair? (cons a (cons '? '()))))
         ((1 q 1) (first-of (cons a (cons '? '()))))
         ((1 q 1) (car/cons a (cons '? '())))
         ((1 e 1) (second-of (cons a (cons '? '()))))
         ((1 e 1 1) (cdr/cons a (cons '? '())))
         ((1 e 1) (car/cons '? '()))
         ((1 e) (equal-same '?))
         ((1) (if-same (equal a '?) 't))
         (() (equal-same 't))))))

  ;; chapter 4

  (defun defun.list0? ()
    (j-bob/define (dethm.in-second-of-pair)
      '(((defun list0? (x)
           (equal x '()))
         nil))))

  (defun defun.list1? ()
    (j-bob/define (defun.list0?)
      '(((defun list1? (x)
           (if (atom x) 'nil (list0? (cdr x))))
         nil))))

  (defun defun.list2? ()
    (j-bob/define (defun.list1?)
      '(((defun list2? (x)
           (if (atom x) 'nil (list1? (cdr x))))
         nil))))

  (defun dethm.contradiction ()
    (j-bob/prove
      (list-extend (prelude)
        '(defun partial (x)
           (if (partial x) 'nil 't)))
      '(((dethm contradiction () 'nil)
         nil
         (() (if-same (partial x) 'nil))
         ((a) (if-nest-a (partial x) 'nil 't))
         ((e) (if-nest-e (partial x) 't 'nil))
         ((a q) (partial x))
         ((e q) (partial x))
         ((a q) (if-nest-a (partial x) 'nil 't))
         ((e q) (if-nest-e (partial x) 'nil 't))
         ((a) (if-false 'nil 't))
         ((e) (if-true 't 'nil))
         (() (if-same (partial x) 't))))))

  (defun defun.list? ()
    (j-bob/define (defun.list2?)
      '(((defun list? (x)
           (if (atom x) (equal x '()) (list? (cdr x))))
         (size x)
         ((q) (natp/size x))
         (() (if-true (if (atom x) 't (< (size (cdr x)) (size x))) 'nil))
         ((e) (size/cdr x))
         (() (if-same (atom x) 't))))))

  (defun defun.sub ()
    (j-bob/define (defun.list?)
      '(((defun sub (x y)
           (if (atom y) (if (equal y '?) x y) (cons (sub x (car y)) (sub x (cdr y)))))
         (size y)
         ((q) (natp/size y))
         (()
          (if-true
            (if (atom y)
                't
                (if (< (size (car y)) (size y)) (< (size (cdr y)) (size y)) 'nil))
            'nil))
         ((e q) (size/car y))
         ((e a) (size/cdr y))
         ((e) (if-true 't 'nil))
         (() (if-same (atom y) 't))))))

  ;; chapter 5

  (defun defun.memb? ()
    (j-bob/define (defun.sub)
      '(((defun memb? (xs)
           (if (atom xs) 'nil (if (equal (car xs) '?) 't (memb? (cdr xs)))))
         (size xs)
         ((q) (natp/size xs))
         (()
          (if-true
            (if (atom xs) 't (if (equal (car xs) '?) 't (< (size (cdr xs)) (size xs))))
            'nil))
         ((e e) (size/cdr xs))
         ((e) (if-same (equal (car xs) '?) 't))
         (() (if-same (atom xs) 't))))))

  (defun defun.remb ()
    (j-bob/define (defun.memb?)
      '(((defun remb (xs)
           (if (atom xs)
               '()
               (if (equal (car xs) '?) (remb (cdr xs)) (cons (car xs) (remb (cdr xs))))))
         (size xs)
         ((q) (natp/size xs))
         (() (if-true (if (atom xs) 't (< (size (cdr xs)) (size xs))) 'nil))
         ((e) (size/cdr xs))
         (() (if-same (atom xs) 't))))))

  (defun dethm.memb?/remb0 ()
    (j-bob/define (defun.remb)
      '(((dethm memb?/remb0 ()
           (equal (memb? (remb '())) 'nil))
         nil
         ((1 1) (remb '()))
         ((1 1 q) (atom '()))
         ((1 1)
          (if-true '()
            (if (equal (car '()) '?) (remb (cdr '())) (cons (car '()) (remb (cdr '()))))))
         ((1) (memb? '()))
         ((1 q) (atom '()))
         ((1) (if-true 'nil (if (equal (car '()) '?) 't (memb? (cdr '())))))
         (() (equal-same 'nil))))))

  (defun dethm.memb?/remb1 ()
    (j-bob/define (dethm.memb?/remb0)
      '(((dethm memb?/remb1 (x1)
           (equal (memb? (remb (cons x1 '()))) 'nil))
         nil
         ((1 1) (remb (cons x1 '())))
         ((1 1 q) (atom/cons x1 '()))
         ((1 1)
          (if-false '()
            (if (equal (car (cons x1 '())) '?)
                (remb (cdr (cons x1 '())))
                (cons (car (cons x1 '())) (remb (cdr (cons x1 '())))))))
         ((1 1 q 1) (car/cons x1 '()))
         ((1 1 a 1) (cdr/cons x1 '()))
         ((1 1 e 1) (car/cons x1 '()))
         ((1 1 e 2 1) (cdr/cons x1 '()))
         ((1)
          (if-same (equal x1 '?)
            (memb? (if (equal x1 '?) (remb '()) (cons x1 (remb '()))))))
         ((1 a 1) (if-nest-a (equal x1 '?) (remb '()) (cons x1 (remb '()))))
         ((1 e 1) (if-nest-e (equal x1 '?) (remb '()) (cons x1 (remb '()))))
         ((1 a) (memb?/remb0))
         ((1 e) (memb? (cons x1 (remb '()))))
         ((1 e q) (atom/cons x1 (remb '())))
         ((1 e)
          (if-false 'nil
            (if (equal (car (cons x1 (remb '()))) '?)
                't
                (memb? (cdr (cons x1 (remb '())))))))
         ((1 e q 1) (car/cons x1 (remb '())))
         ((1 e e 1) (cdr/cons x1 (remb '())))
         ((1 e) (if-nest-e (equal x1 '?) 't (memb? (remb '()))))
         ((1 e) (memb?/remb0))
         ((1) (if-same (equal x1 '?) 'nil))
         (() (equal-same 'nil))))))

  (defun dethm.memb?/remb2 ()
    (j-bob/define (dethm.memb?/remb1)
      '(((dethm memb?/remb2 (x1 x2)
           (equal (memb? (remb (cons x2 (cons x1 '())))) 'nil))
         nil
         ((1 1) (remb (cons x2 (cons x1 '()))))
         ((1 1 q) (atom/cons x2 (cons x1 '())))
         ((1 1)
          (if-false '()
            (if (equal (car (cons x2 (cons x1 '()))) '?)
                (remb (cdr (cons x2 (cons x1 '()))))
                (cons (car (cons x2 (cons x1 '())))
                  (remb (cdr (cons x2 (cons x1 '()))))))))
         ((1 1 q 1) (car/cons x2 (cons x1 '())))
         ((1 1 a 1) (cdr/cons x2 (cons x1 '())))
         ((1 1 e 1) (car/cons x2 (cons x1 '())))
         ((1 1 e 2 1) (cdr/cons x2 (cons x1 '())))
         ((1)
          (if-same (equal x2 '?)
            (memb?
              (if (equal x2 '?) (remb (cons x1 '())) (cons x2 (remb (cons x1 '())))))))
         ((1 a 1)
          (if-nest-a (equal x2 '?) (remb (cons x1 '())) (cons x2 (remb (cons x1 '())))))
         ((1 e 1)
          (if-nest-e (equal x2 '?) (remb (cons x1 '())) (cons x2 (remb (cons x1 '())))))
         ((1 a) (memb?/remb1 x1))
         ((1 e) (memb? (cons x2 (remb (cons x1 '())))))
         ((1 e q) (atom/cons x2 (remb (cons x1 '()))))
         ((1 e)
          (if-false 'nil
            (if (equal (car (cons x2 (remb (cons x1 '())))) '?)
                't
                (memb? (cdr (cons x2 (remb (cons x1 '()))))))))
         ((1 e q 1) (car/cons x2 (remb (cons x1 '()))))
         ((1 e e 1) (cdr/cons x2 (remb (cons x1 '()))))
         ((1 e) (if-nest-e (equal x2 '?) 't (memb? (remb (cons x1 '())))))
         ((1 e) (memb?/remb1 x1))
         ((1) (if-same (equal x2 '?) 'nil))
         (() (equal-same 'nil))))))

  ;; chapter 6

  (defun dethm.memb?/remb ()
    (j-bob/define (dethm.memb?/remb2)
      '(((dethm memb?/remb (xs)
           (equal (memb? (remb xs)) 'nil))
         (list-induction xs)
         ((a 1 1) (remb xs))
         ((a 1 1)
          (if-nest-a (atom xs)
            '()
            (if (equal (car xs) '?) (remb (cdr xs)) (cons (car xs) (remb (cdr xs))))))
         ((a 1) (memb? '()))
         ((a 1 q) (atom '()))
         ((a 1) (if-true 'nil (if (equal (car '()) '?) 't  (memb? (cdr '())))))
         ((a) (equal-same 'nil))
         ((e a 1 1) (remb xs))
         ((e a 1 1)
          (if-nest-e (atom xs)
            '()
            (if (equal (car xs) '?) (remb (cdr xs)) (cons (car xs) (remb (cdr xs))))))
         ((e a 1)
          (if-same (equal (car xs) '?)
            (memb?
              (if (equal (car xs) '?) (remb (cdr xs)) (cons (car xs) (remb (cdr xs)))))))
         ((e a 1 a 1)
          (if-nest-a (equal (car xs) '?) (remb (cdr xs)) (cons (car xs) (remb (cdr xs)))))
         ((e a 1 e 1)
          (if-nest-e (equal (car xs) '?) (remb (cdr xs)) (cons (car xs) (remb (cdr xs)))))
         ((e a 1 a) (equal-if (memb? (remb (cdr xs))) 'nil))
         ((e a 1 e) (memb? (cons (car xs) (remb (cdr xs)))))
         ((e a 1 e q) (atom/cons (car xs) (remb (cdr xs))))
         ((e a 1 e)
          (if-false 'nil
            (if (equal (car (cons (car xs) (remb (cdr xs)))) '?)
                't
                (memb? (cdr (cons (car xs) (remb (cdr xs))))))))
         ((e a 1 e q 1) (car/cons (car xs) (remb (cdr xs))))
         ((e a 1 e e 1) (cdr/cons (car xs) (remb (cdr xs))))
         ((e a 1 e) (if-nest-e (equal (car xs) '?) 't (memb? (remb (cdr xs)))))
         ((e a 1 e) (equal-if (memb? (remb (cdr xs))) 'nil))
         ((e a 1) (if-same (equal (car xs) '?) 'nil))
         ((e a) (equal-same 'nil))
         ((e) (if-same (equal (memb? (remb (cdr xs))) 'nil) 't))
         (() (if-same (atom xs) 't))))))

  ;; chapter 7

  (defun defun.ctx? ()
    (j-bob/define (dethm.memb?/remb)
      '(((defun ctx? (x)
           (if (atom x) (equal x '?) (if (ctx? (car x)) 't (ctx? (cdr x)))))
         (size x)
         ((q) (natp/size x))
         (()
          (if-true
            (if (atom x)
                't
                (if (< (size (car x)) (size x))
                    (if (ctx? (car x)) 't (< (size (cdr x)) (size x)))
                    'nil))
            'nil))
         ((e q) (size/car x))
         ((e a e) (size/cdr x))
         ((e a) (if-same (ctx? (car x)) 't))
         ((e) (if-true 't 'nil))
         (() (if-same (atom x) 't))))))

  (defun dethm.ctx?/sub ()
    (j-bob/define (defun.ctx?)
      '(((dethm ctx?/t (x)
           (if (ctx? x) (equal (ctx? x) 't) 't))
         (star-induction x)
         ((a a 1) (ctx? x))
         ((a a 1) (if-nest-a (atom x) (equal x '?) (if (ctx? (car x)) 't (ctx? (cdr x)))))
         ((a q) (ctx? x))
         ((a q) (if-nest-a (atom x) (equal x '?) (if (ctx? (car x)) 't (ctx? (cdr x)))))
         ((a a 1 1) (equal-if x '?))
         ((a a 1) (equal-same '?))
         ((a a) (equal-same 't))
         ((a) (if-same (equal x '?) 't))
         ((e a a a 1) (ctx? x))
         ((e a a a 1)
          (if-nest-e (atom x) (equal x '?) (if (ctx? (car x)) 't (ctx? (cdr x)))))
         ((e)
          (if-same (ctx? (car x))
            (if (if (ctx? (car x)) (equal (ctx? (car x)) 't) 't)
                (if (if (ctx? (cdr x)) (equal (ctx? (cdr x)) 't) 't)
                    (if (ctx? x) (equal (if (ctx? (car x)) 't (ctx? (cdr x))) 't) 't)
                    't)
                't)))
         ((e a q)	(if-nest-a (ctx? (car x)) (equal (ctx? (car x)) 't) 't))
         ((e a a a a 1) (if-nest-a (ctx? (car x)) 't (ctx? (cdr x))))
         ((e e q) (if-nest-e (ctx? (car x)) (equal (ctx? (car x)) 't) 't))
         ((e e a a a 1) (if-nest-e (ctx? (car x)) 't (ctx? (cdr x))))
         ((e a a a a) (equal-same 't))
         ((e e)
          (if-true
            (if (if (ctx? (cdr x)) (equal (ctx? (cdr x)) 't) 't)
                (if (ctx? x) (equal (ctx? (cdr x)) 't) 't)
                't)
            't))
         ((e a a a) (if-same (ctx? x) 't))
         ((e a a)	(if-same (if (ctx? (cdr x)) (equal (ctx? (cdr x)) 't) 't) 't))
         ((e a) (if-same (equal (ctx? (car x)) 't) 't))
         ((e e a q) (ctx? x))
         ((e e a q)
          (if-nest-e (atom x) (equal x '?) (if (ctx? (car x)) 't (ctx? (cdr x)))))
         ((e e a q) (if-nest-e (ctx? (car x)) 't (ctx? (cdr x))))
         ((e e)
          (if-same (ctx? (cdr x))
            (if (if (ctx? (cdr x)) (equal (ctx? (cdr x)) 't) 't)
                (if (ctx? (cdr x)) (equal (ctx? (cdr x)) 't) 't)
                't)))
         ((e e a q)(if-nest-a (ctx? (cdr x)) (equal (ctx? (cdr x)) 't) 't))
         ((e e a a)(if-nest-a (ctx? (cdr x)) (equal (ctx? (cdr x)) 't) 't))
         ((e e e q)(if-nest-e (ctx? (cdr x)) (equal (ctx? (cdr x)) 't) 't))
         ((e e e a)(if-nest-e (ctx? (cdr x)) (equal (ctx? (cdr x)) 't) 't))
         ((e e e) (if-same 't 't))
         ((e e a a 1) (equal-if (ctx? (cdr x)) 't))
         ((e e a a) (equal-same 't))
         ((e e a) (if-same (equal (ctx? (cdr x)) 't) 't))
         ((e e) (if-same (ctx? (cdr x)) 't))
         ((e) (if-same (ctx? (car x)) 't))
         (() (if-same (atom x) 't)))
        ((dethm ctx?/sub (x y)
           (if (ctx? x) (if (ctx? y) (equal (ctx? (sub x y)) 't) 't) 't))
         (star-induction y)
         (()
          (if-same (ctx? x)
            (if (atom y)
                (if (ctx? x) (if (ctx? y) (equal (ctx? (sub x y)) 't) 't) 't)
                (if (if (ctx? x)
                        (if (ctx? (car y)) (equal (ctx? (sub x (car y))) 't) 't)
                        't)
                    (if (if (ctx? x)
                            (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) 't) 't)
                            't)
                        (if (ctx? x) (if (ctx? y) (equal (ctx? (sub x y)) 't) 't) 't)
                        't)
                    't))))
         ((a a) (if-nest-a (ctx? x) (if (ctx? y) (equal (ctx? (sub x y)) 't) 't) 't))
         ((a e q)
          (if-nest-a (ctx? x) (if (ctx? (car y)) (equal (ctx? (sub x (car y))) 't) 't) 't))
         ((a e a q)
          (if-nest-a (ctx? x) (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) 't) 't) 't))
         ((a e a a) (if-nest-a (ctx? x) (if (ctx? y) (equal (ctx? (sub x y)) 't) 't) 't))
         ((e a) (if-nest-e (ctx? x) (if (ctx? y) (equal (ctx? (sub x y)) 't) 't) 't))
         ((e e q)
          (if-nest-e (ctx? x) (if (ctx? (car y)) (equal (ctx? (sub x (car y))) 't) 't) 't))
         ((e e a q)
          (if-nest-e (ctx? x) (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) 't) 't) 't))
         ((e e a a) (if-nest-e (ctx? x) (if (ctx? y) (equal (ctx? (sub x y)) 't) 't) 't))
         ((e e a) (if-same 't 't))
         ((e e) (if-same 't 't))
         ((e) (if-same (atom y) 't))
         ((a a a 1 1) (sub x y))
         ((a a a 1 1)
          (if-nest-a (atom y)
            (if (equal y '?) x y)
            (cons (sub x (car y)) (sub x (cdr y)))))
         ((a a a)	(if-same (equal y '?) (equal (ctx? (if (equal y '?) x y)) 't)))
         ((a a a a 1 1) (if-nest-a (equal y '?) x y))
         ((a a a e 1 1) (if-nest-e (equal y '?) x y))
         ((a a a a 1) (ctx?/t x))
         ((a a a a) (equal-same 't))
         ((a a a e 1) (ctx?/t y))
         ((a a a e) (equal-same 't))
         ((a a a) (if-same (equal y '?) 't))
         ((a a) (if-same (ctx? y) 't))
         ((a e a a a 1 1) (sub x y))
         ((a e a a a 1 1)
          (if-nest-e (atom y)
            (if (equal y '?) x y)
            (cons (sub x (car y)) (sub x (cdr y)))))
         ((a e a a a 1) (ctx? (cons (sub x (car y)) (sub x (cdr y)))))
         ((a e a a a 1 q) (atom/cons (sub x (car y)) (sub x (cdr y))))
         ((a e a a a 1 e q 1) (car/cons (sub x (car y)) (sub x (cdr y))))
         ((a e a a a 1 e e 1) (cdr/cons (sub x (car y)) (sub x (cdr y))))
         ((a e a a a 1)
          (if-false (equal (cons (sub x (car y)) (sub x (cdr y))) '?)
            (if (ctx? (sub x (car y))) 't (ctx? (sub x (cdr y))))))
         ((a e a a q) (ctx? y))
         ((a e a a q)
          (if-nest-e (atom y) (equal y '?) (if (ctx? (car y)) 't (ctx? (cdr y)))))
         ((a e)
          (if-same (ctx? (car y))
            (if (if (ctx? (car y)) (equal (ctx? (sub x (car y))) 't) 't)
                (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) 't) 't)
                    (if (if (ctx? (car y)) 't (ctx? (cdr y)))
                        (equal (if (ctx? (sub x (car y))) 't (ctx? (sub x (cdr y)))) 't)
                        't)
                    't)
                't)))
         ((a e a q) (if-nest-a (ctx? (car y)) (equal (ctx? (sub x (car y))) 't) 't))
         ((a e a a a q) (if-nest-a (ctx? (car y)) 't (ctx? (cdr y))))
         ((a e e q) (if-nest-e (ctx? (car y)) (equal (ctx? (sub x (car y))) 't) 't))
         ((a e e a a q) (if-nest-e (ctx? (car y)) 't (ctx? (cdr y))))
         ((a e a a a)
          (if-true (equal (if (ctx? (sub x (car y))) 't (ctx? (sub x (cdr y)))) 't) 't))
         ((a e e)
          (if-true
            (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) 't) 't)
                (if (ctx? (cdr y))
                    (equal (if (ctx? (sub x (car y))) 't (ctx? (sub x (cdr y)))) 't)
                    't)
                't)
            't))
         ((a e a a a 1 q) (equal-if (ctx? (sub x (car y))) 't))
         ((a e a a a 1) (if-true 't (ctx? (sub x (cdr y)))))
         ((a e a a a) (equal-same 't))
         ((a e a a) (if-same (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) 't) 't) 't))
         ((a e a) (if-same (equal (ctx? (sub x (car y))) 't) 't))
         ((a e e)
          (if-same (ctx? (cdr y))
            (if (if (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) 't) 't)
                (if (ctx? (cdr y))
                    (equal (if (ctx? (sub x (car y))) 't (ctx? (sub x (cdr y)))) 't)
                    't)
                't)))
         ((a e e a q) (if-nest-a (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) 't) 't))
         ((a e e a a)
          (if-nest-a (ctx? (cdr y))
            (equal (if (ctx? (sub x (car y))) 't (ctx? (sub x (cdr y)))) 't)
            't))
         ((a e e e q) (if-nest-e (ctx? (cdr y)) (equal (ctx? (sub x (cdr y))) 't) 't))
         ((a e e e a)
          (if-nest-e (ctx? (cdr y))
            (equal (if (ctx? (sub x (car y))) 't (ctx? (sub x (cdr y)))) 't)
            't))
         ((a e e e) (if-same 't 't))
         ((a e e a a 1 e) (equal-if (ctx? (sub x (cdr y))) 't))
         ((a e e a a 1) (if-same (ctx? (sub x (car y))) 't))
         ((a e e a a) (equal-same 't))
         ((a e e a) (if-same (equal (ctx? (sub x (cdr y))) 't) 't))
         ((a e e) (if-same (ctx? (cdr y)) 't))
         ((a e) (if-same (ctx? (car y)) 't))
         ((a) (if-same (atom y) 't))
         (() (if-same (ctx? x) 't))))))

  ;; chapter 8

  (defun defun.member? ()
    (j-bob/define (dethm.ctx?/sub)
      '(((defun member? (x ys)
           (if (atom ys) 'nil (if (equal x (car ys)) 't (member? x (cdr ys)))))
         (size ys)
         ((q) (natp/size ys))
         (()
          (if-true
            (if (atom ys) 't (if (equal x (car ys)) 't (< (size (cdr ys)) (size ys))))
            'nil))
         ((e e) (size/cdr ys))
         ((e) (if-same (equal x (car ys)) 't))
         (() (if-same (atom ys) 't))))))

  (defun defun.set? ()
    (j-bob/define (defun.member?)
      '(((defun set? (xs)
           (if (atom xs) 't (if (member? (car xs) (cdr xs)) 'nil (set? (cdr xs)))))
         (size xs)
         ((q) (natp/size xs))
         (()
          (if-true
            (if (atom xs)
                't
                (if (member? (car xs) (cdr xs)) 't (< (size (cdr xs)) (size xs))))
            'nil))
         ((e e) (size/cdr xs))
         ((e) (if-same (member? (car xs) (cdr xs)) 't))
         (() (if-same (atom xs) 't))))))

  (defun defun.add-atoms ()
    (j-bob/define (defun.set?)
      '(((defun add-atoms (x ys)
           (if (atom x)
               (if (member? x ys) ys (cons x ys))
               (add-atoms (car x) (add-atoms (cdr x) ys))))
         (size x)
         ((q) (natp/size x))
         (()
          (if-true
            (if (atom x)
                't
                (if (< (size (car x)) (size x)) (< (size (cdr x)) (size x)) 'nil))
            'nil))
         ((e q) (size/car x))
         ((e a) (size/cdr x))
         ((e) (if-true 't 'nil))
         (() (if-same (atom x) 't))))))

  (defun defun.atoms ()
    (j-bob/define (defun.add-atoms)
      '(((defun atoms (x)
           (add-atoms x '()))
         nil))))

  (defun dethm.set?/atoms.attempt ()
    (j-bob/prove (defun.atoms)
      '(((dethm set?/add-atoms (a)
           (equal (set? (add-atoms a '())) 't))
         (star-induction a)
         ((e a a 1 1) (add-atoms a '())))
        ((dethm set?/atoms (a)
           (equal (set? (atoms a)) 't))
         nil
         ((1 1) (atoms a))
         ((1) (set?/add-atoms a))
         (() (equal-same 't))))))

  (defun dethm.set?/atoms ()
    (j-bob/define (defun.atoms)
      '(((dethm set?/t (xs)
           (if (set? xs) (equal (set? xs) 't) 't))
         (list-induction xs)
         ((a a 1) (set? xs))
         ((a a 1)
          (if-nest-a (atom xs) 't (if (member? (car xs) (cdr xs)) 'nil (set? (cdr xs)))))
         ((a a) (equal-same 't))
         ((a) (if-same (set? xs) 't))
         ((e a a 1) (set? xs))
         ((e a a 1)
          (if-nest-e (atom xs) 't (if (member? (car xs) (cdr xs)) 'nil (set? (cdr xs)))))
         ((e a q) (set? xs))
         ((e a q)
          (if-nest-e (atom xs) 't (if (member? (car xs) (cdr xs)) 'nil (set? (cdr xs)))))
         ((e a)
          (if-same (member? (car xs) (cdr xs))
            (if (if (member? (car xs) (cdr xs)) 'nil (set? (cdr xs)))
                (equal (if (member? (car xs) (cdr xs)) 'nil (set? (cdr xs))) 't)
                't)))
         ((e a a q) (if-nest-a (member? (car xs) (cdr xs)) 'nil (set? (cdr xs))))
         ((e a a a 1) (if-nest-a (member? (car xs) (cdr xs)) 'nil (set? (cdr xs))))
         ((e a e q) (if-nest-e (member? (car xs) (cdr xs)) 'nil (set? (cdr xs))))
         ((e a e a 1) (if-nest-e (member? (car xs) (cdr xs)) 'nil (set? (cdr xs))))
         ((e a a) (if-false (equal 'nil 't) 't))
         ((e)
          (if-same (set? (cdr xs))
            (if (if (set? (cdr xs)) (equal (set? (cdr xs)) 't) 't)
                (if (member? (car xs) (cdr xs))
                    't
                    (if (set? (cdr xs)) (equal (set? (cdr xs)) 't) 't))
                't)))
         ((e a q) (if-nest-a (set? (cdr xs)) (equal (set? (cdr xs)) 't) 't))
         ((e a a e) (if-nest-a (set? (cdr xs)) (equal (set? (cdr xs)) 't) 't))
         ((e e q) (if-nest-e (set? (cdr xs)) (equal (set? (cdr xs)) 't) 't))
         ((e e a e) (if-nest-e (set? (cdr xs)) (equal (set? (cdr xs)) 't) 't))
         ((e e a) (if-same (member? (car xs) (cdr xs)) 't))
         ((e e) (if-same 't 't))
         ((e a a e 1) (equal-if (set? (cdr xs)) 't))
         ((e a a e) (equal-same 't))
         ((e a a) (if-same (member? (car xs) (cdr xs)) 't))
         ((e a) (if-same (equal (set? (cdr xs)) 't) 't))
         ((e) (if-same (set? (cdr xs)) 't))
         (() (if-same (atom xs) 't)))
        ((dethm set?/nil (xs)
           (if (set? xs) 't (equal (set? xs) 'nil)))
         (list-induction xs)
         ((a q) (set? xs))
         ((a q)
          (if-nest-a (atom xs) 't (if (member? (car xs) (cdr xs)) 'nil (set? (cdr xs)))))
         ((a) (if-true 't (equal (set? xs) 'nil)))
         ((e a e 1) (set? xs))
         ((e a e 1)
          (if-nest-e (atom xs) 't (if (member? (car xs) (cdr xs)) 'nil (set? (cdr xs)))))
         ((e a q) (set? xs))
         ((e a q)
          (if-nest-e (atom xs) 't (if (member? (car xs) (cdr xs)) 'nil (set? (cdr xs)))))
         ((e a)
          (if-same (member? (car xs) (cdr xs))
            (if (if (member? (car xs) (cdr xs)) 'nil (set? (cdr xs)))
                't
                (equal (if (member? (car xs) (cdr xs)) 'nil (set? (cdr xs))) 'nil))))
         ((e a a q) (if-nest-a (member? (car xs) (cdr xs)) 'nil (set? (cdr xs))))
         ((e a a e 1) (if-nest-a (member? (car xs) (cdr xs)) 'nil (set? (cdr xs))))
         ((e a e q) (if-nest-e (member? (car xs) (cdr xs)) 'nil (set? (cdr xs))))
         ((e a e e 1) (if-nest-e (member? (car xs) (cdr xs)) 'nil (set? (cdr xs))))
         ((e a a e) (equal-same 'nil))
         ((e a a) (if-same 'nil 't))
         ((e)
          (if-same (set? (cdr xs))
            (if (if (set? (cdr xs)) 't (equal (set? (cdr xs)) 'nil))
                (if (member? (car xs) (cdr xs))
                    't
                    (if (set? (cdr xs)) 't (equal (set? (cdr xs)) 'nil)))
                't)))
         ((e a q) (if-nest-a (set? (cdr xs)) 't (equal (set? (cdr xs)) 'nil)))
         ((e a a e) (if-nest-a (set? (cdr xs)) 't (equal (set? (cdr xs)) 'nil)))
         ((e e q) (if-nest-e (set? (cdr xs)) 't (equal (set? (cdr xs)) 'nil)))
         ((e e a e) (if-nest-e (set? (cdr xs)) 't (equal (set? (cdr xs)) 'nil)))
         ((e a a) (if-same (member? (car xs) (cdr xs)) 't))
         ((e a) (if-same 't 't))
         ((e e a e 1) (equal-if (set? (cdr xs)) 'nil))
         ((e e a e) (equal-same 'nil))
         ((e e a) (if-same (member? (car xs) (cdr xs)) 't))
         ((e e) (if-same (equal (set? (cdr xs)) 'nil) 't))
         ((e) (if-same (set? (cdr xs)) 't))
         (() (if-same (atom xs) 't)))
        ((dethm set?/add-atoms (a bs)
           (if (set? bs) (equal (set? (add-atoms a bs)) 't) 't))
         (add-atoms a bs)
         ((a a 1 1) (add-atoms a bs))
         ((a a 1 1)
          (if-nest-a (atom a)
            (if (member? a bs) bs (cons a bs))
            (add-atoms (car a) (add-atoms (cdr a) bs))))
         ((a a 1) (if-same (member? a bs) (set? (if (member? a bs) bs (cons a bs)))))
         ((a a 1 a 1) (if-nest-a (member? a bs) bs (cons a bs)))
         ((a a 1 e 1) (if-nest-e (member? a bs) bs (cons a bs)))
         ((a a 1 a) (set?/t bs))
         ((a a 1 e) (set? (cons a bs)))
         ((a a 1 e q) (atom/cons a bs))
         ((a a 1 e e q 1) (car/cons a bs))
         ((a a 1 e e q 2) (cdr/cons a bs))
         ((a a 1 e e e 1) (cdr/cons a bs))
         ((a a 1 e) (if-false 't (if (member? a bs) 'nil (set? bs))))
         ((a a 1 e) (if-nest-e (member? a bs) 'nil (set? bs)))
         ((a a 1 e) (set?/t bs))
         ((a a 1) (if-same (member? a bs) 't))
         ((a a) (equal-same 't))
         ((a) (if-same (set? bs) 't))
         ((e)
          (if-same (set? bs)
            (if (if (set? (add-atoms (cdr a) bs))
                    (equal (set? (add-atoms (car a) (add-atoms (cdr a) bs))) 't)
                    't)
                (if (if (set? bs) (equal (set? (add-atoms (cdr a) bs)) 't) 't)
                    (if (set? bs) (equal (set? (add-atoms a bs)) 't) 't)
                    't)
                't)))
         ((e a a q) (if-nest-a (set? bs) (equal (set? (add-atoms (cdr a) bs)) 't) 't))
         ((e a a a) (if-nest-a (set? bs) (equal (set? (add-atoms a bs)) 't) 't))
         ((e e a q) (if-nest-e (set? bs) (equal (set? (add-atoms (cdr a) bs)) 't) 't))
         ((e e a a) (if-nest-e (set? bs) (equal (set? (add-atoms a bs)) 't) 't))
         ((e e a) (if-same 't 't))
         ((e e)
          (if-same
            (if (set? (add-atoms (cdr a) bs))
                (equal (set? (add-atoms (car a) (add-atoms (cdr a) bs))) 't)
                't)
            't))
         ((e a)
          (if-same (set? (add-atoms (cdr a) bs))
            (if (if (set? (add-atoms (cdr a) bs))
                    (equal (set? (add-atoms (car a) (add-atoms (cdr a) bs))) 't)
                    't)
                (if (equal (set? (add-atoms (cdr a) bs)) 't)
                    (equal (set? (add-atoms a bs)) 't)
                    't)
                't)))
         ((e a a q)
          (if-nest-a (set? (add-atoms (cdr a) bs))
            (equal (set? (add-atoms (car a) (add-atoms (cdr a) bs))) 't)
            't))
         ((e a e q)
          (if-nest-e (set? (add-atoms (cdr a) bs))
            (equal (set? (add-atoms (car a) (add-atoms (cdr a) bs))) 't)
            't))
         ((e a e)
          (if-true
            (if (equal (set? (add-atoms (cdr a) bs)) 't)
                (equal (set? (add-atoms a bs)) 't)
                't)
            't))
         ((e a a a q 1) (set?/t (add-atoms (cdr a) bs)))
         ((e a e q 1) (set?/nil (add-atoms (cdr a) bs)))
         ((e a a a q) (equal 't 't))
         ((e a e q) (equal 'nil 't))
         ((e a a a) (if-true (equal (set? (add-atoms a bs)) 't) 't))
         ((e a e) (if-false (equal (set? (add-atoms a bs)) 't) 't))
         ((e a a a 1 1) (add-atoms a bs))
         ((e a a a 1 1)
          (if-nest-e (atom a)
            (if (member? a bs) bs (cons a bs))
            (add-atoms (car a) (add-atoms (cdr a) bs))))
         ((e a a a 1) (equal-if (set? (add-atoms (car a) (add-atoms (cdr a) bs))) 't))
         ((e a a a) (equal-same 't))
         ((e a a)
          (if-same (equal (set? (add-atoms (car a) (add-atoms (cdr a) bs))) 't) 't))
         ((e a) (if-same (set? (add-atoms (cdr a) bs)) 't))
         ((e) (if-same (set? bs) 't))
         (() (if-same (atom a) 't)))
        ((dethm set?/atoms (a)
           (equal (set? (atoms a)) 't))
         nil
         ((1 1) (atoms a))
         (() (if-true (equal (set? (add-atoms a '())) 't) 't))
         ((q) (if-true 't (if (member? (car '()) (cdr '())) 'nil (set? (cdr '())))))
         ((q q) (atom '()))
         ((q) (set? '()))
         ((a 1) (set?/add-atoms a '()))
         ((a) (equal-same 't))
         (() (if-same (set? '()) 't))))))

  ;; chapter 9

  (defun defun.rotate ()
    (j-bob/define (dethm.set?/atoms)
      '(((defun rotate (x)
           (cons (car (car x)) (cons (cdr (car x)) (cdr x))))
         nil))))

  (defun dethm.rotate/cons ()
    (j-bob/define (defun.rotate)
      '(((dethm rotate/cons (x y z)
           (equal (rotate (cons (cons x y) z)) (cons x (cons y z))))
         nil
         ((1) (rotate (cons (cons x y) z)))
         ((1 1 1) (car/cons (cons x y) z))
         ((1 1) (car/cons x y))
         ((1 2 1 1) (car/cons (cons x y) z))
         ((1 2 1) (cdr/cons x y))
         ((1 2 2) (cdr/cons (cons x y) z))
         (() (equal-same (cons x (cons y z))))))))

  (defun defun.align.attempt ()
    (j-bob/prove (dethm.rotate/cons)
      '(((defun align (x)
           (if (atom x)
               x
               (if (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x)))))
         (size x)
         ((q) (natp/size x))
         (()
          (if-true
            (if (atom x)
                't
                (if (atom (car x))
                    (< (size (cdr x)) (size x))
                    (< (size (rotate x)) (size x))))
            'nil))
         ((e a) (size/cdr x))
         ((e e 1 1 1) (cons/car+cdr x))
         ((e e 2 1) (cons/car+cdr x))
         ((e e 1 1 1 1) (cons/car+cdr (car x)))
         ((e e 2 1 1) (cons/car+cdr (car x)))
         ((e e 1 1) (rotate/cons (car (car x)) (cdr (car x)) (cdr x)))))))

  (defun defun.wt ()
    (j-bob/define (dethm.rotate/cons)
      '(((defun wt (x)
           (if (atom x) '1 (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))))
         (size x)
         ((q) (natp/size x))
         (()
          (if-true
            (if (atom x)
                't
                (if (< (size (car x)) (size x)) (< (size (cdr x)) (size x)) 'nil))
            'nil))
         ((e q) (size/car x))
         ((e a) (size/cdr x))
         ((e) (if-true 't 'nil))
         (() (if-same (atom x) 't))))))

  (defun defun.align ()
    (j-bob/define (defun.wt)
      '(((dethm natp/wt (x)
           (equal (natp (wt x)) 't))
         (star-induction x)
         ((a 1 1) (wt x))
         ((a 1 1) (if-nest-a (atom x) '1 (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))))
         ((a 1) (natp '1))
         ((a) (equal-same 't))
         ((e a a 1 1) (wt x))
         ((e a a 1 1)
          (if-nest-e (atom x) '1 (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))))
         ((e a a)
          (if-true (equal (natp (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))) 't) 't))
         ((e a a q) (equal-if (natp (wt (car x))) 't))
         ((e a a a)
          (if-true (equal (natp (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))) 't) 't))
         ((e a a a q) (natp/+ (wt (car x)) (wt (car x))))
         ((e a a q) (equal-if (natp (wt (car x))) 't))
         ((e a a q) (equal-if (natp (wt (cdr x))) 't))
         ((e a a a a 1) (natp/+ (+ (wt (car x)) (wt (car x))) (wt (cdr x))))
         ((e a a a a) (equal-same 't))
         ((e a a a) (if-same (natp (+ (wt (car x)) (wt (car x)))) 't))
         ((e a a) (if-same (natp (wt (cdr x))) 't))
         ((e a) (if-same (equal (natp (wt (cdr x))) 't) 't))
         ((e) (if-same (equal (natp (wt (car x))) 't) 't))
         (() (if-same (atom x) 't)))
        ((dethm positive/wt (x)
           (equal (< '0 (wt x)) 't))
         (star-induction x)
         ((a 1 2) (wt x))
         ((a 1 2) (if-nest-a (atom x) '1 (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))))
         ((a 1) (< '0 '1))
         ((a) (equal-same 't))
         ((e a a 1 2) (wt x))
         ((e a a 1 2)
          (if-nest-e (atom x) '1 (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))))
         ((e a a)
          (if-true (equal (< '0 (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))) 't) 't))
         ((e a a q) (equal-if (< '0 (wt (car x))) 't))
         ((e a a a)
          (if-true (equal (< '0 (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))) 't) 't))
         ((e a a a q) (positives-+ (wt (car x)) (wt (car x))))
         ((e a a q) (equal-if (< '0 (wt (car x))) 't))
         ((e a a q) (equal-if (< '0 (wt (cdr x))) 't))
         ((e a a a a 1) (positives-+ (+ (wt (car x)) (wt (car x))) (wt (cdr x))))
         ((e a a a a) (equal-same 't))
         ((e a a a) (if-same (< '0 (+ (wt (car x)) (wt (car x)))) 't))
         ((e a a) (if-same (< '0 (wt (cdr x))) 't))
         ((e a) (if-same (equal (< '0 (wt (cdr x))) 't) 't))
         ((e) (if-same (equal (< '0 (wt (car x))) 't) 't))
         (() (if-same (atom x) 't)))
        ((defun align (x)
           (if (atom x)
               x
               (if (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x)))))
         (wt x)
         ((q) (natp/wt x))
         (()
          (if-true
            (if (atom x)
                't
                (if (atom (car x)) (< (wt (cdr x)) (wt x)) (< (wt (rotate x)) (wt x))))
            'nil))
         ((e a 2) (wt x))
         ((e a 2) (if-nest-e (atom x) '1 (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))))
         ((e a)
          (if-true (< (wt (cdr x)) (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))) 't))
         ((e a q) (natp/wt (cdr x)))
         ((e a a 1) (identity-+ (wt (cdr x))))
         ((e a a) (common-addends-< '0 (+ (wt (car x)) (wt (car x))) (wt (cdr x))))
         ((e a q) (natp/wt (cdr x)))
         ((e a q) (positive/wt (car x)))
         ((e a a) (positives-+ (wt (car x)) (wt (car x))))
         ((e a) (if-same (< '0 (wt (car x))) 't))
         ((e e 1 1) (rotate x))
         ((e e 1) (wt (cons (car (car x)) (cons (cdr (car x)) (cdr x)))))
         ((e e 1 q) (atom/cons (car (car x)) (cons (cdr (car x)) (cdr x))))
         ((e e 1)
          (if-false '1
            (+ (+ (wt (car (cons (car (car x)) (cons (cdr (car x)) (cdr x)))))
                  (wt (car (cons (car (car x)) (cons (cdr (car x)) (cdr x))))))
               (wt (cdr (cons (car (car x)) (cons (cdr (car x)) (cdr x))))))))
         ((e e 1 1 1 1) (car/cons (car (car x)) (cons (cdr (car x)) (cdr x))))
         ((e e 1 1 2 1) (car/cons (car (car x)) (cons (cdr (car x)) (cdr x))))
         ((e e 1 2 1) (cdr/cons (car (car x)) (cons (cdr (car x)) (cdr x))))
         ((e e 1 2) (wt (cons (cdr (car x)) (cdr x))))
         ((e e 1 2 q) (atom/cons (cdr (car x)) (cdr x)))
         ((e e 1 2)
          (if-false '1
            (+ (+ (wt (car (cons (cdr (car x)) (cdr x))))
                  (wt (car (cons (cdr (car x)) (cdr x)))))
               (wt (cdr (cons (cdr (car x)) (cdr x)))))))
         ((e e 1 2 1 1 1) (car/cons (cdr (car x)) (cdr x)))
         ((e e 1 2 1 2 1) (car/cons (cdr (car x)) (cdr x)))
         ((e e 1 2 2 1) (cdr/cons (cdr (car x)) (cdr x)))
         ((e e 2) (wt x))
         ((e e 2) (if-nest-e (atom x) '1 (+ (+ (wt (car x)) (wt (car x))) (wt (cdr x)))))
         ((e e 2 1 1) (wt (car x)))
         ((e e 2 1 1)
          (if-nest-e (atom (car x))
            '1
            (+ (+ (wt (car (car x))) (wt (car (car x)))) (wt (cdr (car x))))))
         ((e e 2 1 2) (wt (car x)))
         ((e e 2 1 2)
          (if-nest-e (atom (car x))
            '1
            (+ (+ (wt (car (car x))) (wt (car (car x)))) (wt (cdr (car x))))))
         ((e e 1)
          (associate-+
            (+ (wt (car (car x))) (wt (car (car x))))
            (+ (wt (cdr (car x))) (wt (cdr (car x))))
            (wt (cdr x))))
         ((e e)
          (common-addends-<
            (+ (+ (wt (car (car x))) (wt (car (car x))))
               (+ (wt (cdr (car x))) (wt (cdr (car x)))))
            (+ (+ (+ (wt (car (car x))) (wt (car (car x)))) (wt (cdr (car x))))
               (+ (+ (wt (car (car x))) (wt (car (car x)))) (wt (cdr (car x)))))
            (wt (cdr x))))
         ((e e 1)
          (associate-+
            (+ (wt (car (car x))) (wt (car (car x))))
            (wt (cdr (car x)))
            (wt (cdr (car x)))))
         ((e e 1)
          (commute-+
            (+ (+ (wt (car (car x))) (wt (car (car x)))) (wt (cdr (car x))))
            (wt (cdr (car x)))))
         ((e e)
          (common-addends-<
            (wt (cdr (car x)))
            (+ (+ (wt (car (car x))) (wt (car (car x)))) (wt (cdr (car x))))
            (+ (+ (wt (car (car x))) (wt (car (car x)))) (wt (cdr (car x))))))
         ((e e)
          (if-true
            (< (wt (cdr (car x)))
               (+ (+ (wt (car (car x))) (wt (car (car x)))) (wt (cdr (car x)))))
            't))
         ((e e q) (natp/wt (cdr (car x))))
         ((e e a 1) (identity-+ (wt (cdr (car x)))))
         ((e e a)
          (common-addends-<
            '0
            (+ (wt (car (car x))) (wt (car (car x))))
            (wt (cdr (car x)))))
         ((e e q) (natp/wt (cdr (car x))))
         ((e e q) (positive/wt (car (car x))))
         ((e e a) (positives-+ (wt (car (car x))) (wt (car (car x)))))
         ((e e) (if-same (< '0 (wt (car (car x)))) 't))
         ((e) (if-same (atom (car x)) 't))
         (() (if-same (atom x) 't))))))

  (defun dethm.align/align ()
    (j-bob/define (defun.align)
      '(((dethm align/align (x)
           (equal (align (align x)) (align x)))
         (align x)
         ((a 1 1) (align x))
         ((a 1 1)
          (if-nest-a (atom x)
            x
            (if (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x)))))
         ((a 2) (align x))
         ((a 2)
          (if-nest-a (atom x)
            x
            (if (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x)))))
         ((a 1) (align x))
         ((a 1)
          (if-nest-a (atom x)
            x
            (if (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x)))))
         ((a) (equal-same x))
         ((e a a 1 1) (align x))
         ((e a a 1 1)
          (if-nest-e (atom x)
            x
            (if (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x)))))
         ((e a a 1 1)
          (if-nest-a (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x))))
         ((e a a 2) (align x))
         ((e a a 2)
          (if-nest-e (atom x)
            x
            (if (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x)))))
         ((e a a 2)
          (if-nest-a (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x))))
         ((e a a 1) (align (cons (car x) (align (cdr x)))))
         ((e a a 1 q) (atom/cons (car x) (align (cdr x))))
         ((e a a 1 e q 1) (car/cons (car x) (align (cdr x))))
         ((e a a 1 e a 1) (car/cons (car x) (align (cdr x))))
         ((e a a 1 e a 2 1) (cdr/cons (car x) (align (cdr x))))
         ((e a a 1)
          (if-false (cons (car x) (align (cdr x)))
            (if (atom (car x))
                (cons (car x) (align (align (cdr x))))
                (align (rotate (cons (car x) (align (cdr x))))))))
         ((e a a 1)
          (if-nest-a (atom (car x))
            (cons (car x) (align (align (cdr x))))
            (align (rotate (cons (car x) (align (cdr x)))))))
         ((e a a 1 2) (equal-if (align (align (cdr x))) (align (cdr x))))
         ((e a a)	(equal-same (cons (car x) (align (cdr x)))))
         ((e a) (if-same (equal (align (align (cdr x))) (align (cdr x))) 't))
         ((e e a 1 1) (align x))
         ((e e a 1 1)
          (if-nest-e (atom x)
            x
            (if (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x)))))
         ((e e a 1 1)
          (if-nest-e (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x))))
         ((e e a 2) (align x))
         ((e e a 2)
          (if-nest-e (atom x)
            x
            (if (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x)))))
         ((e e a 2)
          (if-nest-e (atom (car x)) (cons (car x) (align (cdr x))) (align (rotate x))))
         ((e e a 1) (equal-if (align (align (rotate x))) (align (rotate x))))
         ((e e a) (equal-same (align (rotate x))))
         ((e e) (if-same (equal (align (align (rotate x))) (align (rotate x))) 't))
         ((e) (if-same (atom (car x)) 't))
         (() (if-same (atom x) 't)))))))
